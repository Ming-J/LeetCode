6.5
- 6.5.1 Default Arguments

Here provided a default for each parameter. A default argument is
specified as an initializer for a parameter in the parameter list. If
a parameter has a default argument, all the parameters that follow it
must also have default arguments.

````c++
  typedef string::size_type sz;
  string screen(sz ht = 24, sz wid = 80, char backgrnd =' ');
````

To use the default argument, we omit that argument when we call the
function.
Can call screen with 0, 1, 2, 3 arguments:

````c++
string window;
window = screen(); // screen(24,80,'')
window = screen(66) // screen(66,80,'')
window = screen(66,256) //screen(66,256,'')
window = screen(66,256,'#') //screen(66,256,'#')
````

The default arguments are used for the trailing(right-most) arguments
of a call

Part of the work of designing a function with default
arguments is ordering the parameters so that those least likely to use
a default appear first and those most likely to use a default appear
last.

-Default Argument Declarations

Each parameter can have its default specified only once in a given
scope.

````c++
//no default for the height or width parameters
string screen(sz,sz, char = ' ') 

string screen(sz,sz, char ='*') //error:redeclaration

string screen(sz = 24, sz = 80, char)  //ok: adds default
````
-Default Argument Initializers

Local Variable may not used as a default argument. A default argument
can be any expression that has a type is convertible to the type of
parameter

````c++

sz wd = 80;
char def = ' ';
sz ht();
string screen(sz=ht(), sz = wd, char = def);
string window = screen(); calls screen(ht(),80,'')

````

name used as default are resolved in the scope of the function declaration.


6.5.2 Inline and constexpr Function

Using function ensures uniform behavior

It's easier to change the function than find and change every
occurence of the equivlent.

The function can be reused rather than rewritten for other applications

Only Drawback: Calling a function is apt to be slower than evaluting
the equivalent expression. Need to do the following:
-Registers are saved before the call and restored after the return
-Arguments may be compied
-Program branches to a new lovation

Inline functions avoid function call overhead

A function specificed as inline is expanded "in line" at each call.
The funtime overhead of making shorterstring a function is thus removed.

````c++
cout<< (s1.size() < s2.size() ? s1 : s2)

//inline version inline const string & shorterString(const string &s1,
const string &s2){ return s1.size() <= s2.size() ? s1 : s2; }

````

inline mechanism is meant to optimze small, straight-line functions
that are called frequently. Many complier will not inline a recursive
function.

constexpr Functions

A function can be used in a constant expression. Like any other
function but must meet certain restrictions: Retrun type and the type
of each parameter in a must be a literal type, and function body must
contain excatly one return type.

````c++

constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

````

defined new_sz as a constexpr that takes no arguments. The compiler
can verify at compile time that a call to new_sz returns a constant
expression, so we can use new_sz to initialize out constexpre
variable..

the compiler will replace a call to a constexpr function with its
resulting value. constexpr functions are implicaitly inline.

May contain other statements as long as those statements generate no
actions at run time. A constexpr function may contain null statements,
type aliases and using declarations.

A constexpr function is permitted to return a value that is not a
constant:
````c++
//scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) {return new_sz() * cnt}
````

The scale function will return a constant expression if its argument
is a constant expression but not otherwise:
````c++
int arr[scale(2)]; ok: scale(2) is a constant expression
int i = 2;  // i is not a constant expression
int a2[scale(i)]; // error: scale(i) is not a constant expression
````

When we pass a constant expression - such as the iteral 2 - such as on
the int object i - then the return is not a constant expression. If we
use scale in a ontext that requires a constant expression, the
compiler checks that the result is a constant expression. If it is
not, the conpiler will produce an error message.

A constexpr function is not required to return a constant expression.

Put inline and constexpr functions in header files

inline and constexpr functions may be defined multiple times in the
program. The compiler needs the definitions, not just the declaration,
in order to expand the code. All of the definitions of a given inline
or constexpr must match exactly. INline and constexpr functions
normall are defined in headers.


6.5.3

A technique similar to header guards to conditionally execute
debugging code. The orogram will contain debugging code that is
executed only while the program is being developed. When the
application is completed and ready to ship, the debiggin code is
turned off.

- assert and NDEBUG

The assert preprocessor macro

assert is preprocessor macro. A preprocessor macro is a preprocessor
variable that acts somewhat like an inline function.

assert(expr);

exalutes expr and if the expression is false(zero), then assert writes
a messgae and terminates the program. If the expression is
true(non-zero), then assert does nothing.

The assertmacro is defined in the cassert header. Preprocessor names
are managed by the preprocessor not the compiler. we use the
preprocessor names directly and do not provide a using declaration for
them. Refer 'assert` not `std::assert` and provide no `using`
declaration for `assert`

As with preprocessor variable, macro names must be uniqu within the
program. Programs that include the `cassert` header may not define a
variable, function, or other entity named `assert`.

the `assert` macro is often used to check for ocnditions that cannot
happen. A programthat does some manipulation of input text might know
that all words it is given are always longer than threshold.

````c++
assert(word.size() > threshold);
````

The NDEBUG Preprocessor variable

The behavior of assert depends on the status of a preprocessor
variable named NDEBUG. If NDEBUG is defined, assert does nothing. By
default, NDEBUG is not defined, so by default, assert performs a
run-time check.

Can turn off debugging by providing a #define to define
NDEBUG. Alternatively, most compilers provide a command-line option
that lets us define preprocessor variable.

''''c++
CC -D NDEBUG main.c # use /D with Microsoft compiler
''''

has the same effect as writting #define NDEBUG at the begining of main.C

If NDEBUG is defined, avoid potential run0time overhead involved in
checking various condition. (No run time check) assert should be used
only to verify things that truly should not be possible. Useful as an
aid in getting a program debugged but should not be used to subtitute
for run time logic check or error checking that the program should do.

````c++ void

print(const int ia[], size_t size){
#ifndef NDEBUG
//__func__ is a local static defined by the compiler that holds the
//function name
cerr << __func __ << ": array size is" << size <<endl;
#endif } ````


