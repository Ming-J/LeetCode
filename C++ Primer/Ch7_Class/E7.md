#7 Class

Fundamental ideas behind classes

-Data Abstraction : programming technique that relies on separation of
 inteeface and implementation.
 	   - interface : operations that user of the calss can execute
	   - implementation: data member, bodies of functions , any
	     functions that need to define the class that are not
	     intended for general use.
-Encapsulation : enforce separation of a class interface and implementation
A class that is encapsulate hides it's implementation - users of the
class can use intface but have no access to the implementation

A class that uses data abstraction and encapsulation defines an
abstract data type.
Class designer worries about how class is implementation
Programmer who use the class need not know how the type works.

# 7.1 Defining Abstract Data Type

## 7.1.2 Defining the Revised Sales_data Class

Introducing this

````c++
std:: string isbn() const {return bookNo};
````

total.isbn();  -> returning total.bookNo.

member functions access the object on which they were called through
an extra implicit parameter. this is initialized with the address of
the object on which the function was invoked.

the compiler passes the address of toal to implicit this parameter in
isbn.
total.isbn()  -> Sales_data::isbn(&total);

Inside member function, refer directly to the members of the object on
the function was called.

Direct use of a member is assumed to be an implicit reference through
this.  this -> bookNo.

Legal but unnessessary, this is a const pointer, can not change the
address.

````c++
std::string isbn() const { return this-> bookNo; }
````

#Introduction const Member Function

The const keyword that follow the parameter list. The purpose of that
const is to modify the type of the implicit this pointer.

`this` is a `const` pointer to the non`const` version of the class type.

type of this in a Sales_data is Sales_data *const.

We cannot bind `this` to a `const` object. means that we cannot call
an ordinary member function on a `const` object.

If isbn were an ordinary function and if this were an ordinary pointer
parameter, we would declare `this` as const Sales_data *const. the
body of isbn doesn;t change the object to which this points, so our
function would be more flexible if `this` were a pointer to `const`.

Since `this` is implicit and does not appear in the parameter
list. There is no place to indicate that this should be a pointer to
const. The language resloved this by letting us put `const` after the
parameter list of a member function. A `const` following the parameter
list indicates that `this` is a pointer to `const`. Member functions
that use `const` this wat are const member functions.

````c++
//psuedo-code illustration of how the implicit this pointer is use
//this code is illegal: we may not explicitly define the this pointer
//ourselves note that this is a pointer to const because isbn is a
//const member
std::string Sales_data::isbn(const Sales_data *const this)
{return this->isbn; }

````

`this` is a pointer to `const` means that `const` member functions
cannot change the object on which they are called. isbn may be called
but not write to the data members of the objects on which it is
called.

Object that are const, and references or pointers to const objects,
may call only const member functions.

#Class Scope and Member Functions

The compiler processes classes in two steps, the member declarations
are compiled first, after thich the member function bodies are
processed. <e,ber function bodies may use other members of their class
regardless of where in the class those members appear.

#Defining a Member Function outside the Class

Member definition must match it;s declaration.
-Return type
-Parameter list,
-Name must match the declaration in the class nody

Name of a member defined outside the class must include the name of
the class of which it is a member.

````c++
double Sale_data::avg_price() const{
       if (units_sold){
       	  return revenue/units_sold;
       }else{
	  return 0;	
       }
}
````

Sales_data::avg_price, uses the scope operator says we are defining
the function avg_price that is declared in the scope of the sales_data
class.

`revenue` and `uniteds_sold` implicitly referring to the members of Sales_data.

#Defining a function to return "this" Object

````c++
Sales_data& Sales_data::combine(const Sales_data & rhs){
 units_sold += rhs.units_sold; //add the members of rhs into
 revenue += rhs.revenue;       //the members of this object
 return *this;  //return the object on which the function was called
}

total.combine(trans);
````

address of total is bound to the implicit parameter and rhs is bound
to trans.

When defining a function that operates like a built-in operator, our
function should mimic the behavior of that operator. The build-in
assignment operators return thier left-hand operand as an lvalue. To
return an lvalue, our combine function must return a
reference. Because the left-hand operand is a Sales data object, the
return type is Sales data&.

Use *this to access the object as a whole.

## 7.1.3 Defining Nonmember class-related functions

Functions that are conceptually part of a class, but not defined
inside the class, are typically declared (but not defined) in the same
header as the class itself.

#Defineing the read and print Function

````c++

istream &read(istream& is,Sales_data &item){
	double price = 0;
	is>>item.bookNo>>item.units_sold>>price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item){
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

````

Both read and write take a reference to their respective IO class
types. The IO classes are types that cannot be copied, so we may only
pass them by reference.

`print` does not print a newline. Finction that do output should do
minimal formatting. That way user code can decide whether the newline
is needed.

#Defining the add Function

````c++
Sales_data add(const Sales_data & lhs, const Sales_data &rhs){
 Sales_data sum = lhs;
 sum.combine(rhs);
 return sum;
}
````

##7.14 Constructors

Classes control object initialization by defining one or more special
member functions known as constructors.
-Initialize the data members of a class object.
-Same name as the class, no return type

Constructor may not be declared as `const`. When we create a const
object of a class type, the object deos not assume it "constness"
until after the constructor completes the object's
initialization. Constructor can write to `const` objects during their
construction.

The Synthesized Default Constructor

Classes control default initialization by defining a special
constructor, Default constructor. It takes no arguments.

The compiler-generated constructor is known as the **synthesized default constructor**. 
Initial each member data member of the class as follows:
- If there is an in-class initializer, use it to initialize the meber
- Otherwise, default-initialize the member

**Some Classess Cannot rely on the Synthesized Default Constructor**


A class must swfinw it's own default constructor is that the compiler
generates the default for us only if we do not define any other
constructors for the class.

Basic rule if a class requires control to initialize an object in one
case, then the class is likely to require control in all cases.

Objects of built-in or compound type (aray and pointers) have
undefined value when they are default initialized.

Calsses that have members of built-in type or compound type should
ordinarily either initialize those members inside the class or define
their own version of the dault constructor.

A class that has a member that has a class type, and that class
doesn't have a dafault constructor, then compiler can't initialize
that member.


````c++
Sales_data() = default;
Sales_data(const std::string &s,unsigned n, double p): bookNo(s),
		 units_Sold(n), revenue(p*n) {}
Sales_data(std::istream &);
string isbn() const {return bookNo; }
Sales_data& combine(const Sales_data&);
double avg_price() const;
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
````

#What = default mens
Sales_data() = default;

Want this constructor to do exactly the same work as the synthesized
version we had been using.

Ask the compiler to generate the constructr for us by writting =
dafault adter the parameter list.

Appear with the declaration inside the class body or on the definition
outside the class body.

Inside the class, function are inline, if outside the definition of
the class the member will not be inlined by default.

Inline reduced overhead.

#Constructor Initializer List

Specfies initial values for one or more data members of the object
being created.

Is a list of member names, each of which is followed by that members
initial value in parentheses ( or inside curly braces.) Multiple
member initializations are separated by commas.

````c++
//Does not explicitly initialize the units_sold and revenue members.
Sales(const std::string &s): bookNo(s){}
//is the same as
Sales_data(const std::string &s): bookNo(s), units_sold(0)
		 	     	  revenue(0) {}

Sales_data(const std::string &s,unsigned n, double p): bookNo(s),
		 units_Sold(n), revenue(p*n) {}
````

When member is omitted form constructor initializer list, it is
implicity initialized using the same process as is used by the
sythesized default constructor. 


Best for a constructor to use as in-class initializer if one exist and
gives the member the correct value.

Constuctors shoud not override in - class initializers except to use a
different initial value. If you can;t use in-class initializers, each
constructor should explicitly initialize every member of built-in
type. 