#7 Class

Fundamental ideas behind classes

-Data Abstraction : programming technique that relies on separation of
 inteeface and implementation.
 	   - interface : operations that user of the calss can execute
	   - implementation: data member, bodies of functions , any
	     functions that need to define the class that are not
	     intended for general use.
-Encapsulation : enforce separation of a class interface and implementation
A class that is encapsulate hides it's implementation - users of the
class can use intface but have no access to the implementation

A class that uses data abstraction and encapsulation defines an
abstract data type.
Class designer worries about how class is implementation
Programmer who use the class need not know how the type works.

# 7.1 Defining Abstract Data Type

## 7.1.2 Defining the Revised Sales_data Class

Introducing this

````c++
std:: string isbn() const {return bookNo};
````

total.isbn();  -> returning total.bookNo.

member functions access the object on which they were called through
an extra implicit parameter. this is initialized with the address of
the object on which the function was invoked.

the compiler passes the address of toal to implicit this parameter in
isbn.
total.isbn()  -> Sales_data::isbn(&total);

Inside member function, refer directly to the members of the object on
the function was called.

Direct use of a member is assumed to be an implicit reference through
this.  this -> bookNo.

Legal but unnessessary, this is a const pointer, can not change the
address.

````c++
std::string isbn() const { return this-> bookNo; }
````

#Introduction const Member Function

The const keyword that follow the parameter list. The purpose of that
const is to modify the type of the implicit this pointer.

`this` is a `const` pointer to the non`const` version of the class type.

type of this in a Sales_data is Sales_data *const.

We cannot bind `this` to a `const` object. means that we cannot call
an ordinary member function on a `const` object.

If isbn were an ordinary function and if this were an ordinary pointer
parameter, we would declare `this` as const Sales_data *const. the
body of isbn doesn;t change the object to which this points, so our
function would be more flexible if `this` were a pointer to `const`.

Since `this` is implicit and does not appear in the parameter
list. There is no place to indicate that this should be a pointer to
const. The language resloved this by letting us put `const` after the
parameter list of a member function. A `const` following the parameter
list indicates that `this` is a pointer to `const`. Member functions
that use `const` this wat are const member functions.

````c++
//psuedo-code illustration of how the implicit this pointer is use
//this code is illegal: we may not explicitly define the this pointer
//ourselves note that this is a pointer to const because isbn is a
//const member
std::string Sales_data::isbn(const Sales_data *const this)
{return this->isbn; }

````

`this` is a pointer to `const` means that `const` member functions
cannot change the object on which they are called. isbn may be called
but not write to the data members of the objects on which it is
called.

Object that are const, and references or pointers to const objects,
may call only const member functions.

#Class Scope and Member Functions

The compiler processes classes in two steps, the member declarations
are compiled first, after thich the member function bodies are
processed. <e,ber function bodies may use other members of their class
regardless of where in the class those members appear.

#Defining a Member Function outside the Class

Member definition must match it;s declaration.
-Return type
-Parameter list,
-Name must match the declaration in the class nody

Name of a member defined outside the class must include the name of
the class of which it is a member.

````c++
double Sale_data::avg_price() const{
       if (units_sold){
       	  return revenue/units_sold;
       }else{
	  return 0;	
       }
}
````

Sales_data::avg_price, uses the scope operator says we are defining
the function avg_price that is declared in the scope of the sales_data
class.

`revenue` and `uniteds_sold` implicitly referring to the members of Sales_data.

#Defining a function to return "this" Object

````c++
Sales_data& Sales_data::combine(const Sales_data & rhs){
 units_sold += rhs.units_sold; //add the members of rhs into
 revenue += rhs.revenue;       //the members of this object
 return *this;  //return the object on which the function was called
}

total.combine(trans);
````

address of total is bound to the implicit parameter and rhs is bound
to trans.

When defining a function that operates like a built-in operator, our
function should mimic the behavior of that operator. The build-in
assignment operators return thier left-hand operand as an lvalue. To
return an lvalue, our combine function must return a
reference. Because the left-hand operand is a Sales data object, the
return type is Sales data&.

Use *this to access the object as a whole.

## 7.1.3 Defining Nonmember class-related functions

Functions that are conceptually part of a class, but not defined
inside the class, are typically declared (but not defined) in the same
header as the class itself.

#Defineing the read and print Function

````c++

istream &read(istream& is,Sales_data &item){
	double price = 0;
	is>>item.bookNo>>item.units_sold>>price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item){
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

````

Both read and write take a reference to their respective IO class
types. The IO classes are types that cannot be copied, so we may only
pass them by reference.

`print` does not print a newline. Finction that do output should do
minimal formatting. That way user code can decide whether the newline
is needed.

#Defining the add Function

````c++
Sales_data add(const Sales_data & lhs, const Sales_data &rhs){
 Sales_data sum = lhs;
 sum.combine(rhs);
 return sum;
}
````

##7.14 Constructors

Classes control object initialization by defining one or more special
member functions known as constructors.
-Initialize the data members of a class object.
-Same name as the class, no return type

Constructor may not be declared as `const`. When we create a const
object of a class type, the object deos not assume it "constness"
until after the constructor completes the object's
initialization. Constructor can write to `const` objects during their
construction.

The Synthesized Default Constructor

Classes control default initialization by defining a special
constructor, Default constructor. It takes no arguments.

The compiler-generated constructor is known as the **synthesized default constructor**. 
Initial each member data member of the class as follows:
- If there is an in-class initializer, use it to initialize the meber
- Otherwise, default-initialize the member

**Some Classess Cannot rely on the Synthesized Default Constructor**


A class must swfinw it's own default constructor is that the compiler
generates the default for us only if we do not define any other
constructors for the class.

Basic rule if a class requires control to initialize an object in one
case, then the class is likely to require control in all cases.

Objects of built-in or compound type (aray and pointers) have
undefined value when they are default initialized.

Calsses that have members of built-in type or compound type should
ordinarily either initialize those members inside the class or define
their own version of the dault constructor.

A class that has a member that has a class type, and that class
doesn't have a dafault constructor, then compiler can't initialize
that member.


````c++
Sales_data() = default;
Sales_data(const std::string &s,unsigned n, double p): bookNo(s),
		 units_Sold(n), revenue(p*n) {}
Sales_data(std::istream &);
string isbn() const {return bookNo; }
Sales_data& combine(const Sales_data&);
double avg_price() const;
std::string bookNo;
unsigned units_sold = 0;
double revenue = 0.0;
````

#What = default mens
Sales_data() = default;

Want this constructor to do exactly the same work as the synthesized
version we had been using.

Ask the compiler to generate the constructr for us by writting =
dafault adter the parameter list.

Appear with the declaration inside the class body or on the definition
outside the class body.

Inside the class, function are inline, if outside the definition of
the class the member will not be inlined by default.

Inline reduced overhead.

#Constructor Initializer List

Specfies initial values for one or more data members of the object
being created.

Is a list of member names, each of which is followed by that members
initial value in parentheses ( or inside curly braces.) Multiple
member initializations are separated by commas.

````c++
//Does not explicitly initialize the units_sold and revenue members.
Sales(const std::string &s): bookNo(s){}
//is the same as
Sales_data(const std::string &s): bookNo(s), units_sold(0)
		 	     	  revenue(0) {}

Sales_data(const std::string &s,unsigned n, double p): bookNo(s),
		 units_Sold(n), revenue(p*n) {}
````

When member is omitted form constructor initializer list, it is
implicity initialized using the same process as is used by the
sythesized default constructor. 


Best for a constructor to use as in-class initializer if one exist and
gives the member the correct value.

Constuctors shoud not override in - class initializers except to use a
different initial value. If you can;t use in-class initializers, each
constructor should explicitly initialize every member of built-in
type.

Constructor that takes an istream does have work to do.

````c++
Sales_data::Sales_data(std::istream &is){
  read(is, * this);
}

````

Defining Sales_data member named Sales_data. Same name as class.

Members that do not appear in the constructor initializer list are
initialized by the corresponding in-class initalizer or are default
initialized. Meaning when the function body starts executing, bookNo
will be empty string units_sold and revenue will be 0.

##Copy, Assignment, and Destruction

Classes also control what happen when we copy, assign, or destroy
objects of the class type. OBject are copy when initialize a variable
or pass or return an object by value. Objects are assigned when we use
the assignment operator, object are destoryed when they cease to
exist, such as when a local object is destoryed on exit from the block
in which it was created.

Compiler will synthesize them for us, if it's not defined.

##Some class cannot rely on the synthesized versions

Synthesized versions are unlikely to work correctly for classes that
allocate resources that reside outside the class objects
themselves.Like dynamic memories.

Classes needed dynamic memory can use a `vector` or a `string` to
manage the necessary storage. Classes that use vectorand string avoid
the complexities involved in allocating and deallocting memory.

#7.2 Access Control and Encapsulation

Access Specifiers to enforce encapsulation
-`Public` are accessible all oart of the program
       Define the interface to the class	  
-`private` are accessible to the member functions of the class
       Encapsulate the implementation

##`class` or `struct` keyword

`struct` members defined before the first access specifier are `public`
`class` then the members are private

##Friends

A class can allow another class or function to access its non`public`
members by making that class or function a `friend`. a class makes a
functino it's friend by including a declaration for that function
preceded by the keyword `friend`.

````c++
class Sales_data{
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
}
````

Friend declarations may appear only inside a class definition. friends
are not members of the class and are not affected by the access
control of the section in which they are declared.

Benefits of Encapsulation Two important adventages:

-User code cannot inadvertently corrupt the state of an encapsulated
 object.
-The implementation of an encapsulated class can change over time
without requiring changes in user-level code.

Defining data members as `private`, class author is free to make
changes in the data. If implementation changes, only the class code
needs to be examined to see what effect the change may have. User code
needs to change only when the interface changes.

Data are protected form msitakes that users might introduce. If there
is a bug that corrupts an object state, the places to look for the bug
are localized: Only code that is part of the implementation could be
responsible for the error. The search for the mistake is limited,
greatly easing the problems of maintenance and program correctness.

##Declarations for Friends

A friend declaration only specifies access. Not declaration of the
function. To make a friend visible to users of the class we usually
declare each friend in the same header as the class itself.

Thus Sales_data header should provide separate declaration for read,
print, add.


#7.3 Additional Class Features

##Defining a Type Member

In addition to defining data and function members, a class can define
it's own local names for types. Type names defined by a class are
subject to the same access control as any other member and may be
either `public` or `private`.

````c++
class Screen{
public:
	typedef std::string::size_type pos;
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
````

Defined `pos` in the `public` part of `Screen` because we want users
to use that name.Users of Screen should't know that `Screen` uses a
string to hold it's data.. By defining `pos` as a public member, we
can hide this detail of how Screen is implemented.

````c++
class Screen{
public:
	//alternative way to declare a type member using a type alias
	using pos = std::string::size_type;
}
````

Unlike ordinary members, members that define types must appear before
they are used. As a result, type members usually appear at the
begining of the class.

````c++
class Screen{
public:
	typedef std::string::size_type pos;
	Screen() = default;
	//Needed because Screen has another constructor
	//cursor initalized to 0 by it's in-class initializer
	Screen(pos ht, pos wd, char c): height(ht),width(wd),
		       	       	    	content(ht*wd,c) {}
	char get() const //get the character at the cursor
	     {return contents[cursor];} //implicitly inline
	inline char get(pos ht, pos wd) const //explicitly inline
	Screen &move(pos r, pos c); //can be made inline later
private:
	pos cursor = 0;
	pos height = 0, width = 0;
	std::string contents;
};
````

Because we are providing a constructor, the compiler will not generate
a default constructor for us. If our class is to have a default
constrctor, we must say so explicitly. In this case, we use = default
to ask the compiler to synthesize the default constructor's
definition.

Second Constructor implicitly uses the in-class initalizer for the
`cursor` member. If our class did not have an in-class initializer for
`cursor`, we would have explicitly initialized `cursor` along with the
other members.

